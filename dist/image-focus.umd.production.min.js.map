{"version":3,"file":"image-focus.umd.production.min.js","sources":["../src/helpers/assign.ts","../src/sharedStyles.ts","../src/FocusPicker.ts","../src/helpers/noop.ts","../src/retina.svg","../src/FocusedImage.ts","../src/helpers/debounce.ts"],"sourcesContent":["export function assign(target: any, ...sources) {\n  sources.forEach(source =>\n    Object.keys(source).forEach(key => (target[key] = source[key]))\n  );\n  return target;\n}\n","export const CONTAINER_STYLES = {\n  position: 'relative',\n  overflow: 'hidden',\n};\n\nexport const ABSOLUTE_STYLES = {\n  position: 'absolute',\n  top: '0',\n  right: '0',\n  bottom: '0',\n  left: '0',\n};\n","import { noop } from './helpers/noop';\nimport { assign } from './helpers/assign';\nimport { CONTAINER_STYLES } from './sharedStyles';\nimport { Focus, FocusPickerOptions } from './interfaces';\n\nimport retina from './retina.svg';\n\nconst IMAGE_STYLES = {\n  // Get rid of bottom padding from default display\n  display: 'block',\n  // Make image fill container\n  maxWidth: '100%',\n  // Prevent Android refresh on pull down\n  touchAction: 'none',\n};\n\nconst RETINA_STYLES = {\n  position: 'absolute',\n  cursor: 'move',\n\n  // Center the retina\n  transform: 'translate(-50%, -50%)',\n};\n\nconst DEFAULT_OPTIONS: FocusPickerOptions = {\n  onChange: noop,\n  retina,\n};\n\nexport class FocusPicker {\n  container: HTMLElement;\n  img: HTMLImageElement;\n  retina: HTMLImageElement;\n  focus: Focus;\n  private isDragging: boolean;\n  private options: FocusPickerOptions;\n\n  constructor(imageNode: HTMLImageElement, options: FocusPickerOptions = {}) {\n    // Merge options in\n    this.options = assign({}, DEFAULT_OPTIONS, options);\n\n    // Set up references\n    this.img = imageNode;\n    this.container = imageNode.parentElement;\n    this.retina = document.createElement('img');\n    this.retina.src = this.options.retina;\n    this.retina.draggable = false;\n    this.container.appendChild(this.retina);\n\n    // Set up image\n    this.img.draggable = false;\n\n    // Bind events\n    this.startListening();\n\n    // Assign styles\n    assign(this.img.style, IMAGE_STYLES);\n    assign(this.retina.style, RETINA_STYLES);\n    assign(this.container.style, CONTAINER_STYLES);\n\n    // Initialize Focus coordinates\n    this.focus = this.options.focus\n      ? this.options.focus\n      : {\n          x: parseFloat(this.img.getAttribute('data-focus-x')) || 0,\n          y: parseFloat(this.img.getAttribute('data-focus-y')) || 0,\n        };\n\n    // Set the focus\n    this.setFocus(this.focus);\n  }\n\n  public startListening() {\n    // Bind container events\n    this.container.addEventListener('mousedown', this.startDragging);\n    this.container.addEventListener('mousemove', this.handleMove);\n    this.container.addEventListener('mouseup', this.stopDragging);\n    this.container.addEventListener('mouseleave', this.stopDragging);\n    this.container.addEventListener('touchend', this.stopDragging);\n\n    // temporarily cast config objs until this issue is resolved\n    // https://github.com/Microsoft/TypeScript/issues/9548\n    this.container.addEventListener('touchstart', this.startDragging, {\n      passive: true,\n    } as any);\n    this.container.addEventListener('touchmove', this.handleMove, {\n      passive: true,\n    } as any);\n\n    this.img.addEventListener('load', this.updateRetinaPositionFromFocus);\n  }\n\n  public stopListening() {\n    this.container.removeEventListener('mousedown', this.startDragging);\n    this.container.removeEventListener('mousemove', this.handleMove);\n    this.container.removeEventListener('mouseup', this.stopDragging);\n    this.container.removeEventListener('mouseleave', this.stopDragging);\n    this.container.removeEventListener('touchend', this.stopDragging);\n    this.container.removeEventListener('touchstart', this.startDragging);\n    this.container.removeEventListener('touchmove', this.handleMove);\n    this.img.removeEventListener('load', this.updateRetinaPositionFromFocus);\n  }\n\n  public setFocus(focus: Focus) {\n    this.focus = focus;\n    this.img.setAttribute('data-focus-x', focus.x.toString());\n    this.img.setAttribute('data-focus-y', focus.y.toString());\n    this.updateRetinaPositionFromFocus();\n    this.options.onChange(focus);\n  }\n\n  private startDragging = (e: MouseEvent | TouchEvent) => {\n    e.preventDefault();\n    this.isDragging = true;\n    e instanceof MouseEvent\n      ? this.updateCoordinates(e.clientX, e.clientY)\n      : this.updateCoordinates(e.touches[0].clientX, e.touches[0].clientY);\n  };\n\n  private handleMove = (e: MouseEvent | TouchEvent) => {\n    e.preventDefault();\n    if (e instanceof MouseEvent) {\n      this.updateCoordinates(e.clientX, e.clientY);\n    } else {\n      const touch = e.touches[0];\n      const touchedEl = document.elementFromPoint(touch.pageX, touch.pageY);\n      touchedEl !== this.retina && touchedEl !== this.img\n        ? this.stopDragging()\n        : this.updateCoordinates(touch.clientX, touch.clientY);\n    }\n  };\n\n  private stopDragging = () => {\n    this.isDragging = false;\n  };\n\n  private calculateOffsetFromFocus() {\n    const { width, height } = this.img.getBoundingClientRect();\n    const offsetX = width * (this.focus.x / 2 + 0.5);\n    const offsetY = height * (this.focus.y / -2 + 0.5);\n    return { offsetX, offsetY };\n  }\n\n  private updateRetinaPositionFromFocus = () => {\n    this.updateRetinaPosition(this.calculateOffsetFromFocus());\n  };\n\n  private updateRetinaPosition = (offsets: {\n    offsetX: number;\n    offsetY: number;\n  }) => {\n    this.retina.style.top = `${offsets.offsetY}px`;\n    this.retina.style.left = `${offsets.offsetX}px`;\n  };\n\n  private updateCoordinates(clientX: number, clientY: number) {\n    if (!this.isDragging) return; // bail if not dragging\n    const { width, height, left, top } = this.img.getBoundingClientRect();\n\n    // Calculate FocusPoint coordinates\n    const offsetX = clientX - left;\n    const offsetY = clientY - top;\n    const x = (offsetX / width - 0.5) * 2;\n    const y = (offsetY / height - 0.5) * -2;\n\n    // TODO: Figure out an elegant way to use the setFocus API without\n    // having to recalculate the offset from focus\n    this.setFocus({ x, y });\n  }\n}\n","// tslint:disable-next-line:no-empty\nexport const noop = () => {};\n","const img = \"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3e %3cg fill='none' fill-rule='evenodd'%3e %3ccircle id='a' cx='10' cy='10' r='10' fill='black' fill-opacity='.3' /%3e %3ccircle cx='10' cy='10' r='9' stroke='white' stroke-opacity='.8' stroke-width='2'/%3e %3c/g%3e%3c/svg%3e\";\n  export default img;","import { debounce } from './helpers/debounce';\nimport { assign } from './helpers/assign';\nimport { Focus, FocusedImageOptions } from './interfaces';\nimport { CONTAINER_STYLES, ABSOLUTE_STYLES } from './sharedStyles';\n\nconst IMG_STYLES = {\n  // Set these styles in case the image dimensions\n  // are smaller than the container's\n  minHeight: '100%',\n  minWidth: '100%',\n};\n\nconst RESIZE_LISTENER_OBJECT_STYLES = {\n  height: '100%',\n  width: '100%',\n  border: 'none',\n\n  // set these styles to emulate \"visibility: hidden\"\n  // can't use visibility because it breaks the object\n  // events in Firefox\n  opacity: 0,\n  zIndex: -1,\n  pointerEvents: 'none',\n};\n\nconst DEFAULT_OPTIONS: FocusedImageOptions = {\n  debounceTime: 17,\n  updateOnWindowResize: true,\n  updateOnContainerResize: false,\n  containerPosition: 'relative',\n};\n\nexport class FocusedImage {\n  focus: Focus;\n  options: FocusedImageOptions;\n  container: HTMLElement;\n  img: HTMLImageElement;\n  resizeListenerObject: HTMLObjectElement;\n  listening: boolean = false;\n  debounceApplyShift: () => void;\n\n  constructor(\n    private imageNode: HTMLImageElement,\n    options: FocusedImageOptions = {}\n  ) {\n    // Merge in options\n    this.options = assign(DEFAULT_OPTIONS, options);\n\n    // Set up element references\n    this.img = imageNode;\n    this.container = imageNode.parentElement;\n\n    // Set up instance\n    if (this.img['__focused_image_instance__']) {\n      this.img['__focused_image_instance__'].stopListening();\n      this.img.removeEventListener('load', this.applyShift);\n    }\n    this.img['__focused_image_instance__'] = this;\n\n    // Add image load event listener\n    this.img.addEventListener('load', this.applyShift);\n\n    // Set up styles\n    assign(this.container.style, CONTAINER_STYLES);\n    this.container.style.position = this.options.containerPosition;\n    assign(this.img.style, IMG_STYLES, ABSOLUTE_STYLES);\n\n    // Create debouncedShift function\n    this.debounceApplyShift = debounce(\n      this.applyShift,\n      this.options.debounceTime\n    );\n\n    // Initialize focus\n    this.focus = this.options.focus\n      ? this.options.focus\n      : {\n          x: parseFloat(this.img.getAttribute('data-focus-x')) || 0,\n          y: parseFloat(this.img.getAttribute('data-focus-y')) || 0,\n        };\n\n    // Start listening for resize events\n    this.startListening();\n\n    // Set focus\n    this.setFocus(this.focus);\n  }\n\n  public setFocus = (focus: Focus) => {\n    this.focus = focus;\n    this.img.setAttribute('data-focus-x', focus.x.toString());\n    this.img.setAttribute('data-focus-y', focus.y.toString());\n    this.applyShift();\n  };\n\n  public applyShift = () => {\n    const { naturalWidth: imageW, naturalHeight: imageH } = this.img;\n    const {\n      width: containerW,\n      height: containerH,\n    } = this.container.getBoundingClientRect();\n\n    // Amount position will be shifted\n    let hShift = '0';\n    let vShift = '0';\n\n    if (!(containerW > 0 && containerH > 0 && imageW > 0 && imageH > 0)) {\n      return false; // Need dimensions to proceed\n    }\n\n    // Which is over by more?\n    const wR = imageW / containerW;\n    const hR = imageH / containerH;\n\n    // Reset max-width and -height\n    this.img.style.maxHeight = null;\n    this.img.style.maxWidth = null;\n\n    // Minimize image while still filling space\n    if (imageW > containerW && imageH > containerH) {\n      this.img.style[wR > hR ? 'maxHeight' : 'maxWidth'] = '100%';\n    }\n\n    if (wR > hR) {\n      hShift = `${this.calcShift(hR, containerW, imageW, this.focus.x)}%`;\n    } else if (wR < hR) {\n      vShift = `${this.calcShift(wR, containerH, imageH, this.focus.y, true)}%`;\n    }\n\n    this.img.style.top = vShift;\n    this.img.style.left = hShift;\n  };\n\n  public startListening() {\n    if (this.listening) {\n      return;\n    }\n    this.listening = true;\n    if (this.options.updateOnWindowResize) {\n      window.addEventListener('resize', this.debounceApplyShift);\n    }\n    if (this.options.updateOnContainerResize) {\n      const object = document.createElement('object');\n      assign(object.style, RESIZE_LISTENER_OBJECT_STYLES, ABSOLUTE_STYLES);\n      // Use load event callback because contentDocument doesn't exist\n      // until this fires in Firefox\n      object.addEventListener('load', (e: Event) =>\n        object.contentDocument.defaultView.addEventListener('resize', () =>\n          this.debounceApplyShift()\n        )\n      );\n      object.type = 'text/html';\n      object.setAttribute('aria-hidden', 'true');\n      object.tabIndex = -1;\n      this.container.appendChild(object);\n      object.data = 'about:blank';\n      this.resizeListenerObject = object;\n    }\n  }\n\n  public stopListening() {\n    if (!this.listening) {\n      return;\n    }\n    this.listening = false;\n    window.removeEventListener('resize', this.debounceApplyShift);\n    if (\n      this.resizeListenerObject &&\n      this.resizeListenerObject.contentDocument\n    ) {\n      this.resizeListenerObject.contentDocument.defaultView.removeEventListener(\n        'resize',\n        this.debounceApplyShift\n      );\n      this.container.removeChild(this.resizeListenerObject);\n      this.resizeListenerObject = null;\n    }\n  }\n\n  // Calculate the new left/top percentage shift of an image\n  private calcShift(\n    conToImageRatio: number,\n    containerSize: number,\n    imageSize: number,\n    focusSize: number,\n    toMinus?: boolean\n  ) {\n    const containerCenter = Math.floor(containerSize / 2); // Container center in px\n    const focusFactor = (focusSize + 1) / 2; // Focus point of resize image in px\n    const scaledImage = Math.floor(imageSize / conToImageRatio); // Can't use width() as images may be display:none\n    let focus = Math.floor(focusFactor * scaledImage);\n    if (toMinus) focus = scaledImage - focus;\n    let focusOffset = focus - containerCenter; // Calculate difference between focus point and center\n    const remainder = scaledImage - focus; // Reduce offset if necessary so image remains filled\n    const containerRemainder = containerSize - containerCenter;\n    if (remainder < containerRemainder)\n      focusOffset -= containerRemainder - remainder;\n    if (focusOffset < 0) focusOffset = 0;\n\n    return (focusOffset * -100) / containerSize;\n  }\n}\n","export function debounce(func: Function, debounceTime: number) {\n  let timeout: any;\n  return function debouncedFunction(...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), debounceTime);\n  };\n}\n"],"names":["assign","target","sources","forEach","source","Object","keys","key","CONTAINER_STYLES","position","overflow","ABSOLUTE_STYLES","top","right","bottom","left","IMAGE_STYLES","display","maxWidth","touchAction","RETINA_STYLES","cursor","transform","DEFAULT_OPTIONS","onChange","retina","FocusPicker","imageNode","options","e","preventDefault","_this","isDragging","MouseEvent","updateCoordinates","clientX","clientY","touches","touch","touchedEl","document","elementFromPoint","pageX","pageY","img","stopDragging","updateRetinaPosition","calculateOffsetFromFocus","offsets","style","offsetY","offsetX","container","parentElement","createElement","src","this","draggable","appendChild","startListening","focus","x","parseFloat","getAttribute","y","setFocus","addEventListener","startDragging","handleMove","passive","updateRetinaPositionFromFocus","stopListening","removeEventListener","setAttribute","toString","getBoundingClientRect","width","height","IMG_STYLES","minHeight","minWidth","RESIZE_LISTENER_OBJECT_STYLES","border","opacity","zIndex","pointerEvents","debounceTime","updateOnWindowResize","updateOnContainerResize","containerPosition","FocusedImage","func","timeout","applyShift","imageW","naturalWidth","imageH","naturalHeight","containerW","containerH","hShift","vShift","wR","hR","maxHeight","calcShift","debounceApplyShift","args","clearTimeout","setTimeout","listening","window","object","contentDocument","defaultView","_this2","type","tabIndex","data","resizeListenerObject","removeChild","conToImageRatio","containerSize","imageSize","focusSize","toMinus","containerCenter","Math","floor","focusFactor","scaledImage","focusOffset","remainder","containerRemainder"],"mappings":"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"}